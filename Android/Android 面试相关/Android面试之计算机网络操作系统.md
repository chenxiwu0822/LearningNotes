# 计算机网络操作系统

| 时间       | 版本  | 说明           |
| ---------- | ----- | -------------- |
| 2020.10.15 | 0.0.1 | 初创，结构输入 |
|            |       |                |

## 网络

### 一、网络体系

#### 1. 网页中输入url，到渲染整个界面的整个过程，以及中间用了什么协议？

1）过程分析：主要分为三步

- `DNS解析`。用户输入url后，需要通过DNS解析找到域名对应的ip地址，有了ip地址才能找到服务器端。首先会查找浏览器缓存，是否有对应的dns记录。再继续按照操作系统缓存—路由缓存—isp的dns服务器—根服务器的顺序进行DNS解析，直到找到对应的ip地址。

- `客户端（浏览器）和服务器交互`。浏览器根据解析到的ip地址和端口号发起HTTP请求，请求到达传输层，这里也就是TCP层，开始三次握手建立连接。服务器收到请求后，发送相应报文给客户端（浏览器），客户端收到相应报文并进行解析，得到html页面数据，包括html，js，css等。

- `客户端（浏览器）解析html数据`，构建DOM树，再构造呈现树（render树），最终绘制到浏览器页面上。

2）其中涉及到TCP/IP协议簇，包括DNS，TCP，IP，HTTP协议等等。



### 二、TCP

#### 1. TCP的三次握手过程，为什么需要三次，而不是两次或者四次？



![三次握手](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a755aa564f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

只发送两次，服务端是不知道自己发送的消息能不能被客户端接收到。 因为TCP握手是三次，所以此时双方都已经知道自己发送的消息能够被对方收到，所以，第四次的发送就显得多余了。



#### 2. TCP的四次挥手过程？



![四次挥手](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a7697ec29f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

大致意思就是：



- `Client`：我要断开连接了
- `Server`：我收到你的消息了
- `Server`：我也要断开连接了
- `Client`：收到你要断开连接的消息了

之后`Client`等待两个`MSL`(数据包在网络上生存的最长时间)，如果服务端没有回消息就彻底断开了。

#### 3. TCP和UDP有什么区别？

- `TCP`：基于字节流、面向连接、可靠、能够进行全双工通信，除此以外，还能进行流量控制和拥塞控制，不过效率略低
- `UDP`：基于报文、面向无连接、不可靠，但是传输效率高。

总的来说，TCP适用于传输效率要求低，准确性要求高或要求有连接。而UDP适用于对准确性要求较低，传输效率要求较高的场景，比如语音通话、直播等。

#### 4. TCP为什么是一种可靠的协议？如何做到流量控制和拥塞控制？

- TCP可靠：是因为可以做到数据包发送的有序、无差错和无重复。
- 流量控制：是通过滑动窗口实现的，因为发送发和接收方消息发送速度和接收速度不一定对等，所以需要一个滑动窗口来平衡处理效率，并且保证没有差错和有序的接收数据包。
- 拥塞控制：慢开始和拥塞避免、快重传和快恢复算法。这写算法主要是为了适应网络中的带宽而作出的调整。

#### 5. 具体介绍下TCP/IP

TCP/IP一般指的是TCP/IP协议簇，主要包括了多个不同网络间实现信息传输涉及到的各种协议
主要包括以下几层：

- 应用层：主要提供数据和服务。比如HTTP，FTP，DNS等
- 传输层：负责数据的组装，分块。比如TCP，UDP等
- 网络层：负责告诉通信的目的地，比如IP等
- 数据链路层：负责连接网络的硬件部分，比如以太网，WIFI等

#### 6. TCP的三次握手和四次挥手，为什么不是两次握手？为什么挥手多一次呢？

客户端简称A，服务器端简称B

 1）TCP建立连接需要三次握手

- A向B表示想跟B进行连接（A发送`syn`包，A进入`SYN_SENT`状态）
- B收到消息，表示我也准备好和你连接了（B收到`syn`包，需要确认`syn`包，并且自己也发送一个`syn`包，即发送了`syn+ack`包，B进入`SYN_RECV`状态）
- A收到消息，并告诉B表示我收到你也准备连接的信号了（A收到`syn+ack`包，向服务器发送确认包`ack`，AB进入`established`状态）开始连接。

2）TCP断开连接需要四次挥手

- A向B表示想跟B断开连接（A发送`fin`，进入`FIN_WAIT_1`状态）
- B收到消息，但是B消息没发送完，只能告诉A我收到你的断开连接消息（B收到fin，发送ack，进入`CLOSE_WAIT`状态）
- 过一会，B数据发送完毕，告诉A，我可以跟你断开了（B发送fin，进入`LAST_ACK`状态）
- A收到消息，告诉B，可以他断开（A收到fin，发送ack，B进入`close`d状态）

3）为什么挥手多一次
 其实正常的断开和连接都是需要`四次`：

- A发消息给B
- B反馈给A表示正确收到消息
- B发送消息给A
- A反馈给B表示正确收到消息。

但是连接中，第二步和第三步是`可以合并`的，因为连接之前A和B是无联系的，所以没有其他情况需要处理。而断开的话，因为之前两端是正常连接状态，所以第二步的时候不能保证B之前的消息已经发送完毕，所以不能马上告诉A要断开的消息。这就是连接为什么可以少一步的原因。

4）为什么连接需要三次，而不是两次。
 正常来说，我给你发消息，你告诉我能收到，不就代表我们之前通信是正常的吗？

- 简单回答就是，`TCP是双向通信协议`，如果两次握手，不能保证B发给A的消息正确到达。

TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。

TCP是怎么保证可靠传输的？

- `序列号和确认号`。比如连接的一方发送一段80byte数据，会带上一个序列号，比如101。接收方收到数据，回复确认号181（180+1），这样下一次发送消息就会从181开始发送了。

所以握手过程中，比如A发送syn信号给B，初始序列号为120，那么B收到消息，回复`ack`消息，序列号为120+1。同时B发送`syn`信号给A，初始序列号为256，如果收不到A的回复消息，就会重发，否则丢失这个序列号，就无法正常完成后面的通信了。

这就是三次握手的原因。

#### 7. TCP三次握手?

重要标志位：

- ACK：TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。

- SYN(SYNchronization) ：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。

- FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

三次握手、四次挥手过程：

![img](https://api2.mubu.com/v3/document_image/5cf012ac-7f38-45d9-9715-62636bc270bf-2297223.jpg)

- 三次握手：

  - 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，seq为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；

  - 第二次握手：服务器收到SYN报文段，需要对这个SYN报文段进行确认，设置ACK为x+1(即seq+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，seq为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；

  - 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将ACK设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

- 四次挥手：

  - 第一次分手：主机1（可以使客户端，也可以是服务器端），设置seq和ACK，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态，这表示主机1没有数据要发送给主机2了；

  - 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，ACK为seq加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；

  - 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；

  - 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

- “三次握手”的目的：

  “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。主要目的防止server端一直等待，浪费资源。换句话说，即是为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。

- “四次挥手”的原因：

  因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。

### 三、UDP



### 四、HTTP（S）

#### 1. 简单介绍下 Https 的原理

#### 2. HTTP是哪一层的协议，常见的HTTP状态码有哪些，分别代表什么意思？

HTTP协议是应用层的协议。

常见的HTTP状态码有：

| 类别  | 解释                                              |
| :---- | :------------------------------------------------ |
| `1xx` | 请求已经接收，继续处理                            |
| `2xx` | 服务器已经正确处理请求，比如`200`                 |
| `3xx` | 重定向，需要做进一步的处理才能完成请求            |
| `4xx` | 服务器无法理解的请求，比如`404`，访问的资源不存在 |
| `5xx` | 服务器收到请求以后，处理错误                      |

#### 3. HTTP 1.1 和HTTP 2有什么区别？

HTTP 2.0基于HTTP 1.1，与HTTP 2.0增加了：

- 二进制格式：HTTP 1.1使用纯文本进行通信，HTTP 2.0使用二进制进行传输。

- Head压缩：对已经发送的Header使用键值建立索引表，相同的Header使用索引表示。

- 服务器推送：服务器可以进行主动推送

- 多路复用：一个TCP连接可以划分成多个流，每个流都会分配Id，客户端可以借助流和服务端建立全双工进行通信，并且流具有优先级。

  ![HTTP2连接](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a74b1f877e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 4. HTTP和HTTPS有什么区别？

简单来说，HTTP和HTTPS的关系是这样的

```
HTTPS = HTTP + SSL/TLS
```

区别如下： HTTP作用于应用层，使用80端口，起始地址是`http://`，明文传输，消息容易被拦截，串改。 HTTPS作用域传输层，使用443端口，起始地址是`https://`，需要下载CA证书，传输的过程需要加密，安全性高。

#### 5. SSL/TLS的握手过程？

这里借用[《趣谈网络协议》](https://time.geekbang.org/column/intro/85)的图片：

![SSL/TLS](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a751550e46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 6. HTTPS传输过程中是如何处理进行加密的？为什么有对称加密的情况下仍然需要进行非对称加密？

过程和上图类似，依次获取证书，公钥，最后生成对称加密的钥匙进行对称加密。

对称加密可以保证加密效率，但是不能解决密钥传输问题；非对称加密可以解决传输问题，但是效率不高。

#### 7. HTTP的几种请求方法具体介绍？PUT和POST区别？

常见的有四种：

- `GET` 获取资源，没有body，幂等性
- `POST` 增加或者修改资源，有body，非幂等性
- `PUT` 修改资源，有body，幂等性
- `DELETE` 删除资源，幂等性

幂等性的方法:如果一个方法重复执行多次，产生的效果是一样的。

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

#### 8. HTTP1.0 HTTP1.1 HTTP1.2有什么区别

#### 9. HTTP请求和响应报文的格式，以及常用状态码

1）请求报文：

```
   //请求行（包括method、path、HTTP版本）
   GET /path HTTP/1.1
   //Headers
   Host: www.baidu.com
   Content-Type: text/plain
   //Body
   搜索****
```

2）响应报文

```
   //状态行 （包括HTTP版本、状态码，状态信息）
   HTTP/1.1 200 OK
   //Headers
   Content-Type: application/json; charset=utf-8
   //Body
   [{"info":"xixi"}]
```

3）常用状态码

主要分为五种类型：

- 1开头， 代表临时性消息，比如100（继续发送）
- 2开头， 代表请求成功，比如200（OK）
- 3开头， 代表重定向，比如304（内容无改变）
- 4开头， 代表客户端的一些错误，比如403（禁止访问）
- 5开头， 代表服务器的一些错误，比如500

#### 10. 介绍对称加密和非对称加密

1）对称加密，即加密和解密算法不同，但是密钥相同。比如`DES，AES`算法。

```kotlin
数据A --> 算法D（密钥S）--> 加密数据B
加密数据B --> 算法E（密钥S）--> 数据A
```

优点：加/解密速度快、密钥管理简单、适宜一对一的信息加密传输，加密算法简单等。
缺点：密钥有可能被破解，容易被伪造。传输过程中一旦密钥被其他人获知则可以进行数据解密。

2）非对称加密，即加密和解密算法相同，但是密钥不同。私钥自己保存，公钥提供给对方。比如`RSA，DSA`算法。

```kotlin
数据A --> 算法D（公钥）--> 加密数据B
加密数据B --> 算法D（私钥）--> 数据A
```

优点：安全，公钥即使被其他人获知，也无法解密数据。
缺点：需要通信双方都有一套公钥和私钥

#### 11. 数字签名的原理

1）首先，为什么需要数字签名？

防止`被攻击，被伪造`。由于公钥是公开的，别人截获到公钥就能伪造数据进行传输，所以我们需要验证数据的来源。

2）怎么签名？
由于公钥能解密私钥加密的数据，所以私钥也能解密公钥加密的数据。（上图非对称加密A和B代号互换即可）
 所以我们用公钥进行加密后，再用私钥进行一次加密，那么私钥的这次加密就叫`签名`，也就是只有我自己可以进行加密的操作。所以传输数据流程就变成了`加密数据和签名数据`，如果解出来都是同样的数据，那么则数据`安全可靠`。

```kotlin
数据A --> 算法D（公钥）--> 加密数据B
数据A --> 算法D（私钥）--> 签名数据C

加密数据B --> 算法D（私钥）--> 数据A
签名数据C --> 算法D（公钥）--> 数据A
```

#### 12. Https的连接过程，加解密算法的选择，以及为什么？

加密算法的类型基本上分为了两种：

- 对称加密，加密用的密钥和解密用的密钥是同一个，比较有代表性的就是 AES 加密算法；

- 非对称加密，加密用的密钥称为公钥，解密用的密钥称为私钥，经常使用到的 RSA 加密算法就是非对称加密的；

此外，还有Hash单向加密算法：

- HASH算法：MD5, SHA1, SHA256

相比较对称加密而言，非对称加密安全性更高，但是加解密耗费的时间更长，速度慢。

HTTPS = HTTP + SSL，HTTPS 的加密就是在 SSL 中完成的。

这就要从 CA 证书讲起了。CA 证书其实就是数字证书，是由 CA 机构颁发的。至于 CA 机构的权威性，那么是毋庸置疑的，所有人都是信任它的。CA 证书内一般会包含以下内容：

- 证书的颁发机构、版本

- 证书的使用者

- 证书的公钥

- 证书的有效时间

- 证书的数字签名 Hash 值和签名 Hash 算法

客户端如何校验 CA 证书？

- CA 证书中的 Hash 值，其实是用证书的私钥进行加密后的值（证书的私钥不在 CA 证书中）。然后客户端得到证书后，利用证书中的公钥去解密该 Hash 值，得到 Hash-a ；然后再利用证书内的签名 Hash 算法去生成一个 Hash-b 。最后比较 Hash-a 和 Hash-b 这两个的值。如果相等，那么证明了该证书是对的，服务端是可以被信任的；如果不相等，那么就说明该证书是错误的，可能被篡改了，浏览器会给出相关提示，无法建立起 HTTPS 连接。除此之外，还会校验 CA 证书的有效时间和域名匹配等。

HTTPS 中的 SSL 握手建立过程：

- 假设现在有客户端 A 和服务器 B ：

  - 1、首先，客户端 A 访问服务器 B ，比如我们用浏览器打开一个网页 [www.baidu.com](http://www.baidu.com/) ，这时，浏览器就是客户端 A ，百度的服务器就是服务器 B 了。这时候客户端 A 会生成一个随机数1，把随机数1 、自己支持的 SSL 版本号以及加密算法等这些信息告诉服务器 B 。

  - 2、服务器 B 知道这些信息后，然后确认一下双方的加密算法，然后服务端也生成一个随机数 2 ，并将随机数 2 和 CA 颁发给自己的证书一同返回给客户端 A 。

  - 3、客户端 A 得到 CA 证书后，会去校验该 CA 证书的有效性，校验方法在上面已经说过了。校验通过后，客户端生成一个随机数3 ，然后用证书中的公钥加密随机数3 并传输给服务端 B 。

  - 4、服务端 B 得到加密后的随机数3，然后利用私钥进行解密，得到真正的随机数3。

  - 5、最后，客户端 A 和服务端 B 都有随机数1、随机数2、随机数3，然后双方利用这三个随机数生成一个对话密钥。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 AES 算法。

  - 6、客户端 A 通知服务端 B ，指明后面的通讯用对话密钥来完成，同时通知服务器 B 客户端 A 的握手过程结束。

  - 7、服务端 B 通知客户端 A，指明后面的通讯用对话密钥来完成，同时通知客户端 A 服务器 B 的握手过程结束。

  - 8、SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 A 和服务器 B 开始使用相同的对话密钥进行数据通讯。

- 简化如下：

  - 1、客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；

  - 2、互相传递三个随机数，之后通过这三个随机数来生成一个密钥；

  - 3、互相确认密钥，然后握手结束；

  - 4、数据通讯开始，都使用同一个对话密钥来加解密；

可以发现，在 HTTPS 加密原理的过程中把对称加密和非对称加密都利用了起来。即利用了非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处。

### 五、Socket



### 六、DNS



## 计算机基础

#### 1. 有用过什么加密算法？AES,RAS什么原理？

#### 2. Base64算法是什么，是加密算法吗？

- `Base64`是一种将二进制数据转换成64种字符组成的字符串的编码算法，主要用于非文本数据的传输，比如图片。可以将图片这种二进制数据转换成具体的字符串，进行保存和传输。
- 严格来说，不算。虽然它确实把一段二进制数据转换成另外一段数据，但是他的加密和解密是公开的，也就无秘密可言了。所以我更倾向于认为它是一种编码，每个人都可以用base64对二进制数据进行编码和解码。
- `面试加分项`：为了减少混淆，方便复制，减少数据长度，就衍生出一种base58编码。去掉了base64中一些容易混淆的数字和字母（数字0，字母O，字母I，数字1，符号+，符号/）
  大名鼎鼎的比特币就是用的改进后的base58编码，即`Base58Check`编码方式，有了校验机制，加入了hash值。

#### 3. Base64底层

Base64的原理比较简单，每当我们使用Base64时都会先定义一个类似这样的数组：

```
['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
```

上面就是Base64的索引表，字符选用了"A-Z、a-z、0-9、+、/" 64个可打印字符，这是标准的Base64协议规定。在日常使用中我们还会看到“=”或“==”号出现在Base64的编码结果中，“=”在此是作为填充字符出现。

- 第一步，将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。
- 第二步，将上面的24个二进制位每6个一组，共分为4组。
- 第三步，在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。
- 第四步，根据Base64编码对照表（见下图）获得对应的值。

```
0　A　　17　R　　　34　i　　　51　z
1　B　　18　S　　　35　j　　　52　0
2　C　　19　T　　　36　k　　　53　1
3　D　　20　U　　　37　l　　　54　2
4　E　　21　V　　　38　m　　　55　3
5　F　　22　W　　　39　n　　　56　4
6　G　　23　X　　　40　o　　　57　5
7　H　　24　Y　　　41　p　　　58　6
8　I　　25　Z　　　42　q　　　59　7
9　J　　26　a　　　43　r　　　60　8
10　K　　27　b　　　44　s　　　61　9
11　L　　28　c　　　45　t　　　62　+
12　M　　29　d　　　46　u　　　63　/
13　N　　30　e　　　47　v
14　O　　31　f　　　48　w　　　
15　P　　32　g　　　49　x
16　Q　　33　h　　　50　y
```

从上面的步骤我们发现：

- Base64字符表中的字符原本用6个bit就可以表示，现在前面添加2个0，变为8个bit，会造成一定的浪费。因此，Base64编码之后的文本，要比原文大约三分之一。
- 为什么使用3个字节一组呢？因为6和8的最小公倍数为24，三个字节正好24个二进制位，每6个bit位一组，恰好能够分为4组。

如果字节数不足三个:

- 两个字节：两个字节共16个二进制位，依旧按照规则进行分组。此时总共16个二进制位，每6个一组，则第三组缺少2位，用0补齐，得到三个Base64编码，第四组完全没有数据则用“=”补上。因此，上图中“BC”转换之后为“QKM=”；
- 一个字节：一个字节共8个二进制位，依旧按照规则进行分组。此时共8个二进制位，每6个一组，则第二组缺少4位，用0补齐，得到两个Base64编码，而后面两组没有对应数据，都用“=”补上。因此，上图中“A”转换之后为“QQ==”；

Base64就是用6位（2的6次幂就是64）表示字符，因此成为Base64。同理，Base32就是用5位，Base16就是用4位。

## 操作系统

### 进程与线程

### 内存管理



### 文件管理