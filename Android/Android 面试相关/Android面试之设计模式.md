# 设计模式

| 时间       | 版本  | 说明 |
| ---------- | ----- | ---- |
| 2020.10.15 | 0.0.1 | 初创 |
|            |       |      |

#### 1. 常见的设计模式有哪些？用了哪些设计模式？

重点了解以下的几种常用的设计模式：

- 单例模式

- 工厂模式和抽象工厂模式：注意他们的区别。
- 责任链模式：View的事件分发和OkHttp的调用过程都使用到了责任链模式。
- 观察者模式：重要性不言而喻。
- 代理模式：建议了解一下动态代理。

#### 2. 六大原则

设计模式的六大原则是：

- 单一职责：合理分配类和函数的职责
- 开闭原则：开放扩展，关闭修改
- 里式替换：继承
- 依赖倒置：面向接口
- 接口隔离：控制接口的粒度
- 迪米特：一个类应该对其他的类了解最少

#### 3. 单例模式

单例模式被问到的几率很大，通常会问如下几种问题。

#### 4. 单例的常用写法有哪几种？

**懒汉模式**

```java
public class SingleInstance {
	private static SingleInstance instance;
	private SingleInstance() {}
	public static synchronized SingleInstance getInstance() {
		if(instance == null) {
			instance = new SingleInstance();
		}
		return instance;
	}
}
```

该模式的主要问题是每次获取实例都需要同步，造成不必要的同步开销。 

**DCL模式**

```java
public class SingleInstance {
	private static SingleInstance instance;
	private SingleInstance() {}
	public static SingleInstance getInstance() {
		if(instance == null) {
			synchronized (SingleInstance.class) {
				if(instance == null) {
					instance = new SingleInstance();
				}
			}
		}
		return instance;
	}
}
```

高并发环境下可能会发生问题。 

**静态内部类单例**

```java
public class SingleInstance {
	private SingleInstance() {}
	public static SingleInstance getInstance() {
		return SingleHolder.instance;
	}
	
	private static class SingleHolder{
		private static final SingleInstance instance = new SingleInstance();
	}
}
```

**枚举单例**

```java
public enum SingletonEnum {
	INSTANCE
}
```

优点：线程安全和反序列化不会生成新的实例

#### 5. DCL模式会有什么问题？

对象生成实例的过程中，大概会经过以下过程：

1. 为对象分配内存空间。
2. 初始化对象中的成员变量。
3. 将对象指向分配的内存空间（此时对象就不为null）。

由于Jvm会优化指令顺序，也就是说2和3的顺序是不能保证的。在多线程的情况下，当一个线程完成了1、3过程后，当前线程的时间片已用完，这个时候会切换到另一个线程，另一个线程调用这个单例，会使用这个还没初始化完成的实例。 解决方法是使用`volatile`关键字：

```
public class SingleInstance {
	private static volatile SingleInstance instance;
	private SingleInstance() {}
	public static SingleInstance getInstance() {
		if(instance == null) {
			synchronized (SingleInstance.class) {
				if(instance == null) {
					instance = new SingleInstance();
				}
			}
		}
		return instance;
	}
}
```

#### 6. Android源码中有哪些设计模式

**AlertDialog、Notification源码中使用了Bulider（建造者）模式完成参数的初始化：**

定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。即将配置从目标类中隔离出来，避免过多的setter方法。

优点：

- 良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。
- 建造者独立，容易扩展。

缺点：

- 会产生多余的Builder对象以及Director对象，消耗内存。

**日常开发的BaseActivity抽象工厂模式：**

定义：为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。

主题切换的应用：

比如我们的应用中有两套主题，分别为亮色主题LightTheme和暗色主题DarkTheme，这两种主题我们可以通过一个抽象的类或接口来定义，而在对应主题下我们又有各类不同的UI元素，比如Button、TextView、Dialog、ActionBar等，这些UI元素都会分别对应不同的主题，这些UI元素我们也可以通过抽象的类或接口定义，抽象的主题、具体的主题、抽象的UI元素和具体的UI元素之间的关系就是抽象工厂模式最好的体现。

优点：

- 分离接口与实现，面向接口编程，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象该工厂方法模式在切换产品类时更加灵活、容易。

缺点：

- 类文件的爆炸性增加。
- 新的产品类不易扩展。

**Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用：**

定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

ViewGroup事件传递的递归调用就类似一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体体现在View的onTouchEvent方法中返回值的设置，如果onTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对其持有；如果为true则相反，此时View会持有该事件并不再向下传递。

优点：

将请求者和处理者关系解耦，提供代码的灵活性。

缺点：

对链中请求处理者的遍历中，如果处理者太多，那么遍历必定会影响性能，特别是在一些递归调用中，要慎重。

**RxJava的观察者模式：**

定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

ListView/RecyclerView的Adapter的notifyDataSetChanged方法、广播、事件总线机制。

观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于Observer和Observable抽象。

优点：

- 观察者和被观察者之间是抽象耦合，应对业务变化。
- 增强系统灵活性、可扩展性。

缺点：

- 在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式。

**AIDL代理模式：**

定义：为其他对象提供一种代理以控制对这个对象的访问。

静态代理：代码运行前代理类的class编译文件就已经存在。

动态代理：通过反射动态地生成代理者的对象。代理谁将会在执行阶段决定。将原来代理类所做的工作由InvocationHandler来处理。

使用场景：

- 当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。

缺点：

- 对类的增加。

**ListView/RecyclerView/GridView的适配器模式：**

适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

使用场景：

- 接口不兼容。
- 想要建立一个可以重复使用的类。
- 需要一个统一的输出接口，而输入端的类型不可预知。

优点：

- 更好的复用性：复用现有的功能。
- 更好的扩展性：扩展现有的功能。

缺点：

- 过多地使用适配器，会让系统非常零乱，不易于整体把握。例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果出现太多这种情况，无异于一场灾难。

**Context/ContextImpl外观模式：**

要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，门面模式提供一个高层次的接口，使得子系统更易于使用。

使用场景：

- 为一个复杂子系统提供一个简单接口。

优点：

- 对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。
- 外观类对子系统的接口封装，使得系统更易用使用。

缺点：

- 外观类接口膨胀。
- 外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。

#### 7. 通过静态内部类实现单例模式有哪些优点？

```java
public class SingleInstance {
	private SingleInstance() {}
	public static SingleInstance getInstance() {
		return SingleHolder.instance;
	}
	
	private static class SingleHolder{
		private static final SingleInstance instance = new SingleInstance();
	}
}
```

1. 不用 synchronized ，节省时间。
2. 调用 getInstance() 的时候才会创建对象，不调用不创建，节省空间，这有点像传说中的懒汉式。

#### 8. 简单工厂、工厂方法、抽象工厂、Builder模式的区别？

- 简单工厂模式：一个工厂方法创建不同类型的对象。
- 工厂方法模式：一个具体的工厂类负责创建一个具体对象类型。
- 抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象。
- Builder模式：对象的构建与表示分离，它更注重对象的创建过程。

#### 9. 装饰模式和代理模式有哪些区别 ？与桥接模式相比呢？

- 装饰模式是以客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。
- 装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增加。
- 桥接模式的作用于代理、装饰截然不同，它主要是为了应对某个类族有多个变化维度导致子类类型急剧增多的场景。通过桥接模式将多个变化维度隔离开，使得它们可以独立地变化，最后通过组合使它们应对多维变化，减少子类的数量和复杂度。

#### 10. 外观模式和中介模式的区别？

外观模式重点是对外封装统一的高层接口，便于用户使用；而中介模式则是避免多个互相协作的对象直接引用，它们之间的交互通过一个中介对象进行，从而使得它们耦合松散，能够易于应对变化。

#### 11. 策略模式和状态模式的区别？

虽然两者的类型结构是一致的，但是它们的本质却是不一样的。策略模式重在整个算法的替换，也就是策略的替换，而状态模式则是通过状态来改变行为。

#### 12. 适配器模式，装饰者模式，外观模式的异同？

这三个模式的相同之处是，它们都作用于用户与真实被使用的类或系统之间，作一个中间层，起到了让用户间接地调用真实的类的作用。它们的不同之外在于，如上所述的应用场合不同和本质的思想不同。

代理与外观的主要区别在于，代理对象代表一个单一对象，而外观对象代表一个子系统，代理的客户对象无法直接访问对象，由代理提供单独的目标对象的访问，而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是一种原来对象的代表，其它需要与这个对象打交道的操作都是和这个代表交涉的。而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来的类进行一些组合。

外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。

代理模式提供与真实的类一致的接口，意在用代理类来处理真实的类，实现一些特定的服务或真实类的部分功能，Facade（外观）模式注重简化接口，Adapter（适配器）模式注重转换接口。


